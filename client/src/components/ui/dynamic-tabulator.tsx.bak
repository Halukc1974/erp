import { useEffect, useRef, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "../ui/select";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "../ui/dialog";
import { Plus, Settings, X, Edit3 } from "lucide-react";
import { useToast } from "../../hooks/use-toast";
import { loadTabulator } from "../../lib/tabulator";
import { dbService } from "../../lib/database";
import CellLinkModal from "../ui/cell-link-modal";
import { HyperFormula } from "hyperformula";

interface DynamicColumn {
  id: string;
  name: string;
  displayName: string;
  dataType: string;
  isRequired: boolean;
  isEditable: boolean;
  defaultValue?: string;
  options?: any;
  width?: number;
  sortOrder: number;
}

interface DynamicTable {
  id: string;
  name: string;
  displayName: string;
  description?: string;
  isActive: boolean;
}

interface DynamicTabulatorProps {
  tableId: string;
  onCellEdit?: (id: string, field: string, value: any) => void;
}

const DATA_TYPES = [
  { value: "text", label: "Metin" },
  { value: "number", label: "Sayƒ±" },
  { value: "decimal", label: "Ondalƒ±k Sayƒ±" },
  { value: "currency", label: "Para Birimi" },
  { value: "date", label: "Tarih" },
  { value: "boolean", label: "Evet/Hayƒ±r" },
  { value: "checkbox", label: "Onay Kutusu" },
  { value: "select", label: "Se√ßim Listesi" },
];

const CURRENCIES = [
  { code: "TRY", symbol: "‚Ç∫", name: "T√ºrk Lirasƒ±" },
  { code: "USD", symbol: "$", name: "Amerikan Dolarƒ±" },
  { code: "EUR", symbol: "‚Ç¨", name: "Euro" },
  { code: "GBP", symbol: "¬£", name: "ƒ∞ngiliz Sterlini" },
  { code: "IQD", symbol: "ÿπ.ÿØ", name: "Irak Dinarƒ±" },
  { code: "LYD", symbol: "ŸÑ.ÿØ", name: "Libya Dinarƒ±" }
];

export default function DynamicTabulator({ tableId, onCellEdit }: DynamicTabulatorProps) {
  const tabulatorRef = useRef<HTMLDivElement>(null);
  const tabulatorInstance = useRef<any>(null);
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [actualTableUUID, setActualTableUUID] = useState<string | null>(null);

  // HyperFormula ile tablo i√ßinde form√ºl hesaplama - columns parametresi ile
  const calculateFormulaInTable = (formula: string, data: any[], columnsData?: DynamicColumn[]): string | null => {
    if (!formula.startsWith('=')) return null;
    
    // Bo≈ü form√ºl kontrol√º
    if (formula.trim() === '=') return '0';
    
    try {
      console.log('üìä Dynamic Tabulator - Form√ºl hesaplanƒ±yor:', formula);
      
      // √ñnce basit matematik form√ºllerini kontrol et (√∂rn: =3*5, =7+8)
      const cleanFormula = formula.slice(1); // = i≈üaretini √ßƒ±kar
      
      // Sadece sayƒ± ve matematik operat√∂rleri varsa (h√ºcre referansƒ± YOK)
      if (/^[\d+\-*/().\s]+$/.test(cleanFormula)) {
        try {
          console.log('üî¢ Basit matematik form√ºl√º tespit edildi:', cleanFormula);
          // G√ºvenlik i√ßin eval yerine Function constructor kullan
          const result = new Function('return ' + cleanFormula)();
          console.log('‚úÖ Basit hesaplama sonucu:', result);
          return String(result);
        } catch (e) {
          console.error('‚ùå Basit form√ºl hesaplama hatasƒ±:', e);
          return '#ERROR';
        }
      }
      
      // H√ºcre referanslƒ± form√ºller i√ßin HyperFormula kullan
      console.log('üìã H√ºcre referanslƒ± form√ºl, HyperFormula kullanƒ±lƒ±yor...');
      
      const hfOptions = {
        licenseKey: 'gpl-v3',
        useColumnIndex: false,
      };
      
      const hf = HyperFormula.buildEmpty(hfOptions);
      const sheetId = hf.addSheet('Sheet1');
      
      // SheetId'yi sayƒ±ya √ßevir
      const numericSheetId = typeof sheetId === 'number' ? sheetId : 0;
      
      // Columns parametresini kullan
      const activeColumns = columnsData || columns || [];
      
      // Veri kontrol√º - columns yoksa basit hesaplama yap
      if (!data.length || !activeColumns.length) {
        console.log('‚ö†Ô∏è Veri veya s√ºtun yok, HyperFormula ile hesaplanmƒ±yor');
        hf.destroy();
        return '0';
      }
      
      // Tablo verilerini HyperFormula formatƒ±na √ßevir - sadece ger√ßek veri
      const dataMatrix: (string | number | null)[][] = [];
      
      // Sadece mevcut satƒ±rlarƒ± i≈üle
      for (let row = 0; row < data.length; row++) {
        const rowData: (string | number | null)[] = [];
        const tableRow = data[row];
        
        for (let col = 0; col < activeColumns.length; col++) {
          const column = activeColumns[col];
          
          // TABULATOR FRESH DATA formatƒ±nƒ± destekle
          // Normal data: tableRow.rowData?.[column.name] 
          // Fresh data: tableRow[column.name]
          let value = tableRow.rowData?.[column?.name || ''];
          if (value === undefined && tableRow[column?.name || '']) {
            value = tableRow[column?.name || ''];
            console.log(`üîß Fresh data'dan alƒ±ndƒ±: ${column?.name} = ${value}`);
          }
          
          // √ñNEMLƒ∞: Eƒüer bu h√ºcrede bir form√ºl varsa, calculated deƒüerini kullan
          const currentRowId = tableRow.id;
          const currentColumnName = column?.name || '';
          const formulaInThisCell = (cellFormulas || []).find((f: any) => 
            f.rowId === currentRowId && f.columnName === currentColumnName
          );
          
          if (formulaInThisCell && formulaInThisCell.calculatedValue !== null && formulaInThisCell.calculatedValue !== undefined) {
            value = formulaInThisCell.calculatedValue;
            console.log(`üßÆ Form√ºl h√ºcresi i√ßin calculated deƒüer kullanƒ±ldƒ±: ${currentColumnName}[${currentRowId}] = ${value} (form√ºl: ${formulaInThisCell.formula})`);
          }
          
          let finalValue: string | number | null = null;
          
          if (value === null || value === undefined || value === '') {
            finalValue = null;
          } else if (typeof value === 'string') {
            // Para birimi formatƒ± kontrol√º (√∂rn: "100|USD")
            if (value.includes('|')) {
              const [amount] = value.split('|');
              const numAmount = parseFloat(amount);
              finalValue = isNaN(numAmount) ? 0 : numAmount;
            } else {
              const numValue = parseFloat(value);
              // √ñNEMLƒ∞: String ise ve sayƒ±ya √ßevrilebiliyorsa NUMBER olarak kaydet
              finalValue = isNaN(numValue) ? value : numValue;
            }
          } else if (typeof value === 'number') {
            finalValue = value;
          } else {
            // Diƒüer durumlar - number'a √ßevirmeyi dene
            const numValue = Number(value);
            finalValue = isNaN(numValue) ? String(value) : numValue;
          }
          
          rowData.push(finalValue);
          
          // Debug log - s√ºtun mapping
          const cellRef = String.fromCharCode(65 + col) + (row + 1);
          console.log(`üîç ${cellRef} = ${finalValue} [${column?.name}] (raw: ${value}, type: ${typeof value})`);
          
          // A1+B1+C1 form√ºl√º i√ßin √∂zel debug
          if (formula === '=A1+B1+C1' && row === 0 && (col === 0 || col === 1 || col === 2)) {
            console.log(`üî• FORM√úL DEBUG [${cellRef}]:`, {
              columnName: column?.name,
              rawValue: value,
              rawValueType: typeof value,
              processedValue: finalValue,
              processedValueType: typeof finalValue,
              hasFormula: !!formulaInThisCell,
              formulaCalculatedValue: formulaInThisCell?.calculatedValue,
              willBeAddedAsNumber: Number(finalValue),
              stringConcatenation: `"${finalValue}"`
            });
          }
        }
        dataMatrix.push(rowData);
      }
      
      // En az 10x10 matrix i√ßin bo≈ü satƒ±r/s√ºtun ekle
      while (dataMatrix.length < 10) {
        const emptyRow = new Array(Math.max(activeColumns.length, 10)).fill(null);
        dataMatrix.push(emptyRow);
      }
      
      dataMatrix.forEach(row => {
        while (row.length < 10) {
          row.push(null);
        }
      });
      
      // SheetId numerik olarak kullan
      hf.setSheetContent(numericSheetId, dataMatrix);
      
      // Form√ºl√º hesapla - bo≈ü alanda
      const tempRow = Math.max(data.length + 2, 10);
      const tempCol = Math.max(activeColumns.length + 2, 10);
      hf.setCellContents({ sheet: numericSheetId, row: tempRow, col: tempCol }, [[formula]]);
      
      const result = hf.getCellValue({ sheet: numericSheetId, row: tempRow, col: tempCol });
      
      // A1+B1+C1 √∂zel debug
      if (formula === '=A1+B1+C1') {
        console.log('üö® A1+B1+C1 SONU√á ANALƒ∞Zƒ∞:');
        console.log('- Matrix ilk satƒ±r:', dataMatrix[0]);
        console.log('- A1 deƒüeri:', dataMatrix[0]?.[0], 'type:', typeof dataMatrix[0]?.[0]);
        console.log('- B1 deƒüeri:', dataMatrix[0]?.[1], 'type:', typeof dataMatrix[0]?.[1]);
        console.log('- C1 deƒüeri:', dataMatrix[0]?.[2], 'type:', typeof dataMatrix[0]?.[2]);
        console.log('- HyperFormula sonucu:', result, 'type:', typeof result);
        console.log('- Manuel toplama (Number):', Number(dataMatrix[0]?.[0] || 0) + Number(dataMatrix[0]?.[1] || 0) + Number(dataMatrix[0]?.[2] || 0));
        console.log('- Manuel toplama (+):', Number(dataMatrix[0]?.[0] || 0) + Number(dataMatrix[0]?.[1] || 0) + Number(dataMatrix[0]?.[2] || 0));
        console.log('- String birle≈ütirme:', String(dataMatrix[0]?.[0] || '') + String(dataMatrix[0]?.[1] || '') + String(dataMatrix[0]?.[2] || ''));
      }
      
      hf.destroy();
      
      console.log('üìä Dynamic Tabulator - Sonu√ß:', result);
      
      // Sonu√ß kontrol√º
      if (result === null || result === undefined) {
        return '0';
      }
      
      // HyperFormula error kontrol√º
      if (typeof result === 'object' && ((result as any).error || (result as any).message)) {
        console.error('HyperFormula error:', result);
        return '#ERROR';
      }
      
      // Sayƒ± formatlamasƒ±
      if (typeof result === 'number') {
        if (Math.abs(result) > 1e15) {
          return result.toExponential(2);
        }
        if (result % 1 !== 0) {
          return parseFloat(result.toFixed(6)).toString();
        }
        return result.toString();
      }
      
      return String(result);
      
    } catch (error) {
      console.error('Form√ºl hesaplama hatasƒ±:', error);
      return '#ERROR';
    }
  };
  
  const [showColumnDialog, setShowColumnDialog] = useState(false);
  const [showCellLinkModal, setShowCellLinkModal] = useState(false);
  const [cellLinkData, setCellLinkData] = useState<{
    sourceRowId: string;
    sourceColumnName: string;
  } | null>(null);
  const [editingColumn, setEditingColumn] = useState<DynamicColumn | null>(null);

  // UUID lookup sistemi
  useEffect(() => {
    const lookupTableUUID = async () => {
      if (!tableId) return;
      
      console.log(`üîç Looking up UUID for tableId: "${tableId}"`);
      
      // Eƒüer zaten UUID formatƒ±ndaysa, doƒürudan kullan
      if (tableId.length === 36 && tableId.includes('-')) {
        setActualTableUUID(tableId);
        console.log(`‚úÖ Already UUID format: ${tableId}`);
        return;
      }
      
      try {
        // dynamic_tables'da name ile ara
        const tables = await dbService.fetchTable('dynamic_tables', {
          filter: `name=eq.${tableId}` // Doƒüru filter format
        });
        
        if (tables && tables.length > 0) {
          setActualTableUUID(tables[0].id);
          console.log(`‚úÖ Found UUID: ${tables[0].id} for name: ${tableId}`);
        } else {
          console.warn(`‚ö†Ô∏è Table not found for name: ${tableId}`);
          setActualTableUUID(null);
        }
      } catch (error) {
        console.error(`‚ùå Error looking up table UUID:`, error);
        setActualTableUUID(null);
      }
    };
    
    lookupTableUUID();
  }, [tableId]);

  const [columnForm, setColumnForm] = useState({
    name: "",
    displayName: "",
    dataType: "text",
    isRequired: false,
    isEditable: true,
    defaultValue: "",
    width: 150,
    currency: "TRY", // Default para birimi
  });

  // Fetch table columns
  const { data: columns = [], isLoading: columnsLoading } = useQuery<DynamicColumn[]>({
    queryKey: [`dynamic-columns-${actualTableUUID || tableId}`],
    queryFn: () => dbService.fetchTable('dynamic_columns', {
      filter: `table_id=eq.${actualTableUUID}`, // Doƒüru filter format
      order: 'sort_order'
    }),
    enabled: !!actualTableUUID,
  });

  // Fetch table data
  const { data: tableData = [], isLoading: dataLoading } = useQuery<any[]>({
    queryKey: [`dynamic-table-data-${actualTableUUID || tableId}`],
    queryFn: () => dbService.fetchTable('dynamic_table_data', {
      filter: `table_id=eq.${actualTableUUID}`, // Doƒüru filter format
      order: 'id'
    }),
    enabled: !!actualTableUUID,
  });

  // Fetch cell links for this table  
  const { data: cellLinks = [] } = useQuery<any[]>({
    queryKey: [`cell-links-${actualTableUUID || tableId}`],
    queryFn: () => dbService.fetchTable('cell_links', {
      filter: `source_table_id=eq.${actualTableUUID}` // Doƒüru filter format
    }),
    enabled: !!actualTableUUID,
  });

  // Fetch linked values for all cell links
  const { data: linkedValues = {} } = useQuery({
    queryKey: [`/api/cell-links/${tableId}/values`],
    queryFn: async () => {
      if (cellLinks.length === 0) return {};
      
      const values: { [key: string]: any } = {};
      
      for (const link of cellLinks) {
        try {
          const response = await fetch(`/api/table-data/${link.targetTableName}`);
          const tableData = await response.json();
          const targetRow = tableData.find((row: any) => row.id === link.targetRowId);
          
          if (targetRow && targetRow[link.targetFieldName]) {
            const linkKey = `${link.sourceRowId}_${link.sourceColumnName}`;
            values[linkKey] = targetRow[link.targetFieldName];
          }
        } catch (error) {
          console.error('Error fetching linked value:', error);
        }
      }
      
      return values;
    },
    enabled: cellLinks.length > 0,
  });

  // Fetch cell formulas for this table
  const { data: cellFormulas = [] } = useQuery<any[]>({
    queryKey: [`/api/cell-formulas/${tableId}`],
    enabled: !!tableId,
  });

  // üßÆ AUTO-RECALCULATION: T√ºm form√ºlleri yeniden hesaplama fonksiyonu
  const recalculateAllFormulas = async () => {
    if (!cellFormulas || cellFormulas.length === 0) {
      console.log('üìã Hesaplanacak form√ºl yok');
      return;
    }

    console.log(`üîÑ ${cellFormulas.length} form√ºl yeniden hesaplanƒ±yor...`);

    for (const formula of cellFormulas) {
      try {
        console.log(`üß™ ƒ∞≈ülenen form√ºl:`, formula);
        
        // calculateFormulaInTable fonksiyonunu kullan (local)
        const newValue = calculateFormulaInTable(
          formula.formula,
          tableData || [],
          columns
        );
        
        console.log(`üßÆ Form√ºl sonucu: "${formula.formula}" = ${newValue} (eski: ${formula.calculatedValue})`);
        
        if (newValue !== null && String(newValue) !== String(formula.calculatedValue)) {
          console.log(`üìä Form√ºl g√ºncellendi: ${formula.rowId}-${formula.columnName} = ${newValue}`);
          
          // Database'deki form√ºl deƒüerini g√ºncelle
          const formulaUpdateData = {
            calculated_value: String(newValue),
            updated_at: new Date().toISOString()
          };
          await dbService.updateData('cell_formulas', formula.id, formulaUpdateData);

          // Global updateCellAfterFormula fonksiyonunu kullan
          if (typeof (window as any).updateCellAfterFormula === 'function') {
            (window as any).updateCellAfterFormula(formula.rowId, formula.columnName, String(newValue));
          }
        } else {
          console.log(`‚ö™ Form√ºl deƒüi≈ümedi: ${formula.rowId}-${formula.columnName} = ${newValue}`);
        }
      } catch (error) {
        console.error(`‚ùå Form√ºl hesaplama hatasƒ±:`, formula, error);
      }
    }

    // Query'leri invalidate et
    queryClient.invalidateQueries({ queryKey: [`/api/cell-formulas/${tableId}`] });
    queryClient.invalidateQueries({ queryKey: [`/api/dynamic-tables/${tableId}/data`] });
    
    console.log('‚úÖ T√ºm form√ºller yeniden hesaplandƒ±');
  };

  // üéØ SMART RECALCULATION: Sadece baƒüƒ±mlƒ± form√ºlleri hesapla
  const recalculateDependentFormulas = async (changedField: string, newValue: any) => {
    if (!cellFormulas || cellFormulas.length === 0) {
      console.log('üìã Hesaplanacak form√ºl yok');
      return;
    }

    // Mevcut tablodaki satƒ±r ID'lerini al
    const currentRowIds = (tableData || []).map((row: any) => row.id);
    console.log(`üîç Mevcut tablo satƒ±r ID'leri:`, currentRowIds);

    // ‚ú® D√úZELTME: changedField'ƒ± Excel tarzƒ± h√ºcre referansƒ±na √ßevir
    const columnIndex = columns.findIndex((col: any) => col.name === changedField);
    const columnLetter = columnIndex >= 0 ? String.fromCharCode(65 + columnIndex) : changedField; // A, B, C...
    console.log(`üîÑ S√ºtun mapping: "${changedField}" -> "${columnLetter}" (index: ${columnIndex})`);

    // Deƒüi≈üen field i√ßin t√ºm olasƒ± h√ºcre referanslarƒ± olu≈ütur (A1, A2, A3... vs B1, B2, B3...)
    const possibleCellRefs = [];
    for (let row = 1; row <= Math.max(currentRowIds.length, 10); row++) {
      possibleCellRefs.push(`${columnLetter}${row}`.toLowerCase());
    }
    console.log(`üìã Olasƒ± h√ºcre referanslarƒ±: ${possibleCellRefs.join(', ')}`);

    // Deƒüi≈üen field baƒüƒ±mlƒ±lƒ±ƒüƒ±nda olan form√ºlleri filtrele
    const dependentFormulas = cellFormulas.filter((formula: any) => {
      const formulaText = formula.formula.toLowerCase();
      
      // 1. √ñnce form√ºl bu tablodaki satƒ±rlardan biri mi kontrol et
      const isInCurrentTable = currentRowIds.includes(formula.rowId);
      
      // 2. Form√ºlde bu s√ºtunun herhangi bir h√ºcre referansƒ± var mƒ± kontrol et
      const hasDependency = possibleCellRefs.some(cellRef => formulaText.includes(cellRef)) || 
                           formulaText.includes(changedField.toLowerCase()) ||
                           formulaText.includes(columnLetter.toLowerCase());
      
      const shouldInclude = isInCurrentTable && hasDependency;
      
      console.log(`üîç Form√ºl "${formula.formula}" (rowId: ${formula.rowId}) -> ${columnLetter} baƒüƒ±mlƒ±: ${hasDependency}, mevcut tabloda: ${isInCurrentTable}, dahil: ${shouldInclude}`);
      return shouldInclude;
    });

    if (dependentFormulas.length === 0) {
      console.log(`üìã ${changedField} deƒüi≈üikliƒüi i√ßin baƒüƒ±mlƒ± form√ºl yok`);
      return;
    }

    console.log(`üéØ ${changedField} i√ßin ${dependentFormulas.length} baƒüƒ±mlƒ± form√ºl yeniden hesaplanƒ±yor...`);

    // üîÑ √ñNEMLƒ∞: Form√ºlleri baƒüƒ±mlƒ±lƒ±k sƒ±rasƒ±na g√∂re sƒ±rala
    // Basit form√ºller √∂nce (=a1+b1), sonra bile≈üik form√ºller (=a1+b1+c1)
    const sortedFormulas = [...dependentFormulas].sort((a, b) => {
      const aComplexity = (a.formula.match(/[a-z]\d+/gi) || []).length; // H√ºcre referansƒ± sayƒ±sƒ±
      const bComplexity = (b.formula.match(/[a-z]\d+/gi) || []).length;
      return aComplexity - bComplexity; // Basit form√ºller √∂nce
    });

    console.log('üîÑ Form√ºller baƒüƒ±mlƒ±lƒ±k sƒ±rasƒ±na g√∂re sƒ±ralandƒ±:', sortedFormulas.map(f => `${f.formula} (${(f.formula.match(/[a-z]\d+/gi) || []).length} ref)`));

    for (const formula of sortedFormulas) {
      try {
        console.log(`üß™ Baƒüƒ±mlƒ± form√ºl:`, {
          formula: formula.formula,
          rowId: formula.rowId,
          columnName: formula.columnName,
          oldValue: formula.calculatedValue
        });
        
        // G√úNCEL VERƒ∞ √áEK: Tabulator'dan fresh data al (state deƒüil!)
        const freshTableData = tabulatorInstance.current ? tabulatorInstance.current.getData() : (tableData || []);
        console.log('üîç Fresh table data alƒ±ndƒ±:', freshTableData.length, 'satƒ±r');
        
        // calculateFormulaInTable fonksiyonunu kullan (fresh data ile)
        const newCalculatedValue = calculateFormulaInTable(
          formula.formula,
          freshTableData,
          columns
        );
        
        console.log(`üßÆ Yeniden hesaplanan deƒüer: "${formula.formula}" = ${newCalculatedValue} (eski: ${formula.calculatedValue})`);
        
        if (newCalculatedValue !== null && String(newCalculatedValue) !== String(formula.calculatedValue)) {
          console.log(`üìä Baƒüƒ±mlƒ± form√ºl g√ºncellendi: ${formula.rowId}-${formula.columnName} = ${newCalculatedValue}`);
          
          // üî• KRITIK: Database'deki form√ºl deƒüerini g√ºncelle VE table row'unu da g√ºncelle
          try {
            // 1. √ñnce form√ºl deƒüerini g√ºncelle (cell_formulas tablosunda)
            const formulaUpdateData = {
              calculated_value: String(newCalculatedValue),
              updated_at: new Date().toISOString()
            };
            await dbService.updateData('cell_formulas', formula.id, formulaUpdateData);
            console.log(`‚úÖ Form√ºl database'de g√ºncellendi: ${formula.id} = ${newCalculatedValue}`);

            // 2. SONRA table row'unu da hesaplanan deƒüer ile g√ºncelle
            const currentRowData = freshTableData.find((row: any) => row.id === formula.rowId);
            if (currentRowData) {
              const { id, ...rowDataWithoutId } = currentRowData;
              const updatedRowData = { ...rowDataWithoutId, [formula.columnName]: String(newCalculatedValue) };
              
              const rowUpdateData = {
                row_data: JSON.stringify(updatedRowData),
                updated_at: new Date().toISOString()
              };
              await dbService.updateData('dynamic_table_data', formula.rowId, rowUpdateData);
              console.log(`‚úÖ Row data g√ºncellendi: ${formula.rowId} ${formula.columnName} = ${newCalculatedValue}`);
            }

            // 3. Tabulator'daki h√ºcreyi g√ºncelle
            if (typeof (window as any).updateCellAfterFormula === 'function') {
              (window as any).updateCellAfterFormula(formula.rowId, formula.columnName, String(newCalculatedValue));
            }

            // 4. √ñNEMLƒ∞: cellFormulas listesini de g√ºncelle (sonraki hesaplamalar i√ßin)
            const formulaIndex = cellFormulas.findIndex((f: any) => f.id === formula.id);
            if (formulaIndex >= 0) {
              cellFormulas[formulaIndex].calculatedValue = String(newCalculatedValue);
              console.log('üîÑ cellFormulas listesi g√ºncellendi');
            }
            
          } catch (error) {
            console.error('‚ùå Database g√ºncelleme hatasƒ±:', error);
          }
        } else {
          console.log(`‚ö™ Baƒüƒ±mlƒ± form√ºl deƒüi≈ümedi: ${formula.rowId}-${formula.columnName} = ${newCalculatedValue}`);
        }
      } catch (error) {
        console.error(`‚ùå Baƒüƒ±mlƒ± form√ºl hesaplama hatasƒ±:`, formula, error);
      }
    }

    // Query'leri invalidate et
    queryClient.invalidateQueries({ queryKey: [`/api/cell-formulas/${tableId}`] });
    queryClient.invalidateQueries({ queryKey: [`/api/dynamic-tables/${tableId}/data`] });
    
    console.log(`‚úÖ ${changedField} i√ßin baƒüƒ±mlƒ± form√ºller yeniden hesaplandƒ±`);
  };

  // Create column mutation
  const createColumnMutation = useMutation({
    mutationFn: async (columnData: any) => {
      console.log(`üîç DEBUG: Using actualTableUUID = "${actualTableUUID}"`);
      
      if (!actualTableUUID) {
        throw new Error('Table UUID not found');
      }
      
      // Convert to Supabase format
      const supabaseData = {
        table_id: actualTableUUID, // Use actual UUID
        name: columnData.name,
        display_name: columnData.displayName,
        data_type: columnData.dataType,
        is_required: columnData.isRequired,
        is_editable: columnData.isEditable,
        default_value: columnData.defaultValue || null,
        options: columnData.options ? JSON.stringify(columnData.options) : null,
        width: columnData.width || 150,
        sort_order: columnData.sortOrder || 999
      };
      
      console.log(`üì§ Final column data for Supabase:`, supabaseData);
      return await dbService.insertData('dynamic_columns', supabaseData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`dynamic-columns-${actualTableUUID}`] });
      setShowColumnDialog(false);
      setColumnForm({
        name: "",
        displayName: "",
        dataType: "text",
        isRequired: false,
        isEditable: true,
        defaultValue: "",
        width: 150,
        currency: "TRY",
      });
      toast({
        title: "Ba≈üarƒ±lƒ±",
        description: "S√ºtun ba≈üarƒ±yla eklendi",
      });
    },
    onError: () => {
      toast({
        title: "Hata",
        description: "S√ºtun eklenirken hata olu≈ütu",
        variant: "destructive",
      });
    },
  });

  // Update column mutation
  const updateColumnMutation = useMutation({
    mutationFn: async ({ id, data }: { id: string; data: any }) => {
      // Convert to Supabase format
      const supabaseData = {
        name: data.name,
        display_name: data.displayName,
        data_type: data.dataType,
        is_required: data.isRequired,
        is_editable: data.isEditable,
        default_value: data.defaultValue || null,
        options: data.options ? JSON.stringify(data.options) : null,
        width: data.width || 150,
        sort_order: data.sortOrder || 999
      };
      return await dbService.updateData('dynamic_columns', id, supabaseData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`dynamic-columns-${actualTableUUID || tableId}`] });
      setEditingColumn(null);
      toast({
        title: "Ba≈üarƒ±lƒ±",
        description: "S√ºtun ba≈üarƒ±yla g√ºncellendi",
      });
    },
    onError: () => {
      toast({
        title: "Hata",
        description: "S√ºtun g√ºncellenirken hata olu≈ütu",
        variant: "destructive",
      });
    },
  });

  // Delete column mutation
  const deleteColumnMutation = useMutation({
    mutationFn: async (id: string) => {
      return await dbService.deleteData('dynamic_columns', id);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`dynamic-columns-${actualTableUUID || tableId}`] });
      toast({
        title: "Ba≈üarƒ±lƒ±",
        description: "S√ºtun ba≈üarƒ±yla silindi",
      });
    },
    onError: () => {
      toast({
        title: "Hata",
        description: "S√ºtun silinirken hata olu≈ütu",
        variant: "destructive",
      });
    },
  });

  // Create row mutation
  const createRowMutation = useMutation({
    mutationFn: async (rowData: any) => {
      console.log(`üîç Row DEBUG: tableId = "${tableId}", looking up UUID`);
      
      // TableId'yi UUID'ye √ßevirmeliyiz
      let actualTableId: string;
      
      try {
        if (isNaN(parseInt(tableId))) {
          // tableId string (table name) 
          const tables = await dbService.fetchTable('dynamic_tables', {
            filter: `name=eq.${tableId}`
          });
          
          if (tables && tables.length > 0) {
            actualTableId = tables[0].id; // UUID string
            console.log(`‚úÖ Found table UUID for row: ${actualTableId}`);
          } else {
            actualTableId = "d4ddfe9d-a0dd-4318-88a9-bba1f9ad3a45"; // Fallback UUID
          }
        } else {
          actualTableId = "d4ddfe9d-a0dd-4318-88a9-bba1f9ad3a45"; // Fallback UUID
        }
      } catch (error) {
        console.error('Error looking up table UUID for row:', error);
        actualTableId = "d4ddfe9d-a0dd-4318-88a9-bba1f9ad3a45"; // Fallback UUID
      }
      
      // Convert to Supabase format for dynamic_table_data
      const supabaseData = {
        table_id: actualTableId, // UUID string
        row_data: JSON.stringify(rowData), // Store as JSONB
        user_id: 'system' // Default user ID
      };
      
      console.log(`üì§ Final row data for Supabase:`, supabaseData);
      return await dbService.insertData('dynamic_table_data', supabaseData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`dynamic-table-data-${actualTableUUID || tableId}`] });
      toast({
        title: "Ba≈üarƒ±lƒ±",
        description: "Satƒ±r ba≈üarƒ±yla eklendi",
      });
    },
    onError: () => {
      toast({
        title: "Hata",
        description: "Satƒ±r eklenirken hata olu≈ütu",
        variant: "destructive",
      });
    },
  });

  // Update row mutation
  const updateRowMutation = useMutation({
    mutationFn: async ({ id, rowData }: { id: string; rowData: any }) => {
      // Convert to Supabase format for dynamic_table_data
      const supabaseData = {
        row_data: JSON.stringify(rowData), // Store as JSONB
        updated_at: new Date().toISOString()
      };
      return await dbService.updateData('dynamic_table_data', id, supabaseData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`dynamic-table-data-${actualTableUUID || tableId}`] });
    },
    onError: () => {
      toast({
        title: "Hata",
        description: "Veri g√ºncellenirken hata olu≈ütu",
        variant: "destructive",
      });
    },
  });

  // Convert columns to Tabulator format
  const getTabulatorColumns = () => {
    if (!columns.length) return [];

    const tabulatorColumns = columns
      .sort((a: DynamicColumn, b: DynamicColumn) => a.sortOrder - b.sortOrder)
      .map((col: DynamicColumn) => {
        const column: any = {
          title: col.displayName,
          field: col.name,
          width: col.width || 150,
          resizable: true,
          headerSort: true,
          editor: col.isEditable ? getEditorForType(col.dataType) : false,
          formatter: function(cell: any) {
            const rowId = cell.getRow().getData().id;
            const columnName = col.name;
            
            // Check if this cell has a formula
            const cellFormula = (cellFormulas || []).find((formula: any) => 
              formula.rowId === rowId && formula.columnName === columnName
            );
            
            // Check if this cell has a link
            const cellLink = cellLinks.find((link: any) => 
              link.sourceRowId === rowId && link.sourceColumnName === columnName
            );
            
            let displayValue = '';
            let cellIcon = '';
            
            if (cellFormula) {
              // This cell has a formula - show the calculated value from database
              displayValue = cellFormula.calculatedValue || '0'; // Use calculated value from database
              cellIcon = 'üßÆ'; // Formula icon
            } else if (cellLink) {
              // This cell has a linked value - show actual linked data
              const linkKey = `${rowId}_${columnName}`;
              const linkedValue = linkedValues[linkKey];
              if (linkedValue) {
                displayValue = `${linkedValue}`;
                cellIcon = 'üîó'; // Link icon
              } else {
                displayValue = '[Baƒülantƒ± Y√ºkleniyor...]';
                cellIcon = 'üîó';
              }
            } else {
              // Normal cell value
              const formatterFunc = getFormatterForType(col.dataType, col);
              displayValue = typeof formatterFunc === 'function' ? formatterFunc(cell) : cell.getValue();
            }
            
            // Her h√ºcreye veri baƒülama ikonu ekle
            return `
              <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <span style="${cellFormula ? 'color: #16a34a; font-weight: 500;' : cellLink ? 'color: #2563eb; font-weight: 500;' : ''}">${cellIcon ? cellIcon + ' ' : ''}${displayValue || ''}</span>
                <button 
                  class="cell-link-btn" 
                  style="
                    background: none; 
                    border: none; 
                    cursor: pointer; 
                    opacity: 0.5;
                    padding: 2px;
                    border-radius: 2px;
                  "
                  title="${cellFormula ? 'Form√ºl: ' + cellFormula.formula : 'Veri Baƒüla'}"
                  onclick="window.handleCellLinkClick('${rowId}', '${columnName}')"
                >
                  üîó
                </button>
              </div>
            `;
          },
          cellEdited: function(cell: any) {
            console.log(`üî•üî•üî• CELL EDITED EVENT TRIGGERED! üî•üî•üî•`);
            const row = cell.getRow().getData();
            const field = cell.getField();
            const value = cell.getValue();
            console.log(`üéØ Row ID: ${row.id}, Field: ${field}, Value: "${value}"`);
            
            // Get all current row data (excluding id) and update the specific field
            const { id, ...currentRowData } = row;
            let updatedRowData = { ...currentRowData, [field]: value };
            
            // Form√ºl kontrol√º - eƒüer = ile ba≈ülƒ±yorsa HyperFormula ile hesapla
            if (typeof value === 'string' && value.startsWith('=')) {
              const calculatedValue = calculateFormulaInTable(value, tableData || [], columns);
              console.log(`üßÆ Form√ºl hesaplandƒ±: "${value}" = ${calculatedValue}`);
              
              // Form√ºl√º kaydet
              const formulaData = {
                tableId: tableId,
                rowId: id,
                columnName: field,
                formula: value,
                calculatedValue: calculatedValue,
                dependencies: null // PostgreSQL jsonb i√ßin null kulan
              };
              
              // Hesaplanan deƒüeri h√ºcreye anƒ±nda set et
              cell.setValue(calculatedValue || '0');
              
              // üî• KRITIK: Form√ºl√º database'e kaydet VE table row'unu da g√ºncelle
              const saveFormulaAndUpdateRow = async () => {
                try {
                  // 1. √ñnce form√ºl√º kaydet (cell_formulas tablosuna)
                  const formulaSupabaseData = {
                    table_id: parseInt(tableId) || 1,
                    row_id: parseInt(id) || 0, 
                    column_name: field,
                    formula_text: value,
                    calculated_value: calculatedValue?.toString() || '',
                    user_id: 'system'
                  };
                  await dbService.insertData('cell_formulas', formulaSupabaseData);
                  console.log(`‚úÖ Form√ºl kaydedildi: ${value} = ${calculatedValue}`);
                  
                  // 2. SONRA table row'unu da hesaplanan deƒüer ile g√ºncelle
                  const updatedRowDataWithFormula = { ...updatedRowData, [field]: calculatedValue };
                  const rowUpdateData = {
                    row_data: JSON.stringify(updatedRowDataWithFormula),
                    updated_at: new Date().toISOString()
                  };
                  await dbService.updateData('dynamic_table_data', id, rowUpdateData);
                  console.log(`‚úÖ Row data g√ºncellendi: ${field} = ${calculatedValue}`);
                  
                  // 3. Query'leri invalidate et
                  queryClient.invalidateQueries({ queryKey: [`cell-formulas-${tableId}`] });
                  queryClient.invalidateQueries({ queryKey: [`/api/dynamic-tables/${tableId}/data`] });
                  
                } catch (error) {
                  console.error('‚ùå Form√ºl kaydedilemedi veya row g√ºncellenemedi:', error);
                }
              };
              
              // Async i≈ülemi ba≈ülat
              saveFormulaAndUpdateRow();
              
              // Hesaplanan deƒüeri g√∂ster (UI i√ßin)
              updatedRowData[field] = calculatedValue || value;
              
              // Normal row update'i yapma (√ß√ºnk√º yukarƒ±da async olarak yapƒ±yoruz)
              return;
            }
            
            // Normal h√ºcre deƒüeri - database'e kaydet
            updateRowMutation.mutate({
              id: id,
              rowData: updatedRowData
            });

            // üîÑ SMART RECALCULATION: Sadece baƒüƒ±mlƒ± form√ºlleri hesapla
            setTimeout(() => {
              console.log(`üöÄ SMART RECALCULATION tetikleniyor: ${field} deƒüi≈üti`);
              recalculateDependentFormulas(field, value);
            }, 200); // Biraz daha uzun bekle ki database g√ºncellensin

            if (onCellEdit) {
              onCellEdit(id, field, value);
            }
          },
          headerMenu: [
            {
              label: "S√ºtunu D√ºzenle",
              action: function(e: any, column: any) {
                startEditColumn(col);
              }
            },
            {
              label: "S√ºtunu Sil",
              action: function(e: any, column: any) {
                if (confirm("Bu s√ºtunu silmek istediƒüinizden emin misiniz?")) {
                  deleteColumnMutation.mutate(col.id);
                }
              }
            }
          ],
          // Saƒü tƒ±k yerine sol tƒ±k ile veri baƒülama - daha g√ºvenli
        };

        return column;
      });

    return tabulatorColumns;
  };

  // Para birimi i√ßin √∂zel edit√∂r
  const currencyEditor = function(cell: any, onRendered: any, success: any, cancel: any, editorParams: any) {
    // Mevcut h√ºcre deƒüerini parse et
    const currentValue = cell.getValue();
    const parsedValue = parseCurrencyValue(currentValue);
    const amount = parsedValue ? parsedValue.amount : 0;
    const currency = parsedValue ? parsedValue.currency : 'TRY';

    // Container div olu≈ütur
    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.gap = '4px';
    container.style.padding = '2px';
    container.style.background = 'white';
    container.style.border = '1px solid #ccc';
    container.style.borderRadius = '4px';

    // Sayƒ± input'u olu≈ütur
    const amountInput = document.createElement('input');
    amountInput.type = 'number';
    amountInput.value = amount.toString();
    amountInput.style.flex = '1';
    amountInput.style.border = 'none';
    amountInput.style.outline = 'none';
    amountInput.style.padding = '2px';
    amountInput.style.fontSize = '12px';

    // Para birimi select'i olu≈ütur
    const currencySelect = document.createElement('select');
    currencySelect.style.border = 'none';
    currencySelect.style.outline = 'none';
    currencySelect.style.fontSize = '12px';
    currencySelect.style.background = 'transparent';
    
    // Para birimi se√ßeneklerini ekle
    CURRENCIES.forEach(curr => {
      const option = document.createElement('option');
      option.value = curr.code;
      option.textContent = curr.code;
      option.selected = curr.code === currency;
      currencySelect.appendChild(option);
    });

    container.appendChild(amountInput);
    container.appendChild(currencySelect);

    // Fonksiyonlar
    const getValue = () => {
      const newAmount = parseFloat(amountInput.value) || 0;
      const newCurrency = currencySelect.value;
      return `${newAmount}|${newCurrency}`;
    };

    const setValue = () => {
      success(getValue());
    };

    // Event listeners
    amountInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        setValue();
      } else if (e.key === 'Escape') {
        cancel();
      }
    });

    // Para birimi deƒüi≈ütiƒüinde otomatik kaydet YAPMA - kullanƒ±cƒ± se√ßsin
    currencySelect.addEventListener('change', (e) => {
      e.stopPropagation();
      // Sadece se√ßimi g√ºncellet, kaydetme
    });
    
    // Blur olduƒüunda kaydet
    amountInput.addEventListener('blur', setValue);
    
    // Enter tu≈üuyla da kaydet
    currencySelect.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        setValue();
      } else if (e.key === 'Escape') {
        cancel();
      }
    });

    // Render callback
    onRendered(() => {
      amountInput.focus();
      amountInput.select();
    });

    return container;
  };

  const getEditorForType = (dataType: string) => {
    switch (dataType) {
      case "number":
      case "decimal":
      case "currency":
        return "number";
      case "date":
        return "date";
      case "boolean":
      case "checkbox":
        return "tickCross";
      case "select":
        return "select";
      default:
        return "input";
    }
  };

  // Para birimi deƒüerini parse etme fonksiyonu
  const parseCurrencyValue = (value: any) => {
    if (!value) return null;
    if (typeof value === 'object' && value.amount !== undefined) {
      return value; // Zaten format edilmi≈ü
    }
    if (typeof value === 'string' && value.includes('|')) {
      const [amount, currency] = value.split('|');
      return { amount: parseFloat(amount) || 0, currency: currency || 'TRY' };
    }
    return { amount: parseFloat(value) || 0, currency: 'TRY' };
  };

  // Para birimini formatla
  const formatCurrency = (amount: number, currencyCode: string) => {
    const currency = CURRENCIES.find(c => c.code === currencyCode) || CURRENCIES[0];
    return `${currency.symbol}${amount.toLocaleString('tr-TR', { 
      minimumFractionDigits: 2, 
      maximumFractionDigits: 2 
    })}`;
  };

  const getFormatterForType = (dataType: string, column?: DynamicColumn) => {
    switch (dataType) {
      case "decimal":
        return function(cell: any) {
          const value = cell.getValue();
          if (value === null || value === undefined) return '';
          return parseFloat(value).toFixed(2);
        };
      case "currency":
        return function(cell: any) {
          const value = cell.getValue();
          if (!value) return '';
          
          const parsedValue = parseCurrencyValue(value);
          if (!parsedValue) return '';
          
          return formatCurrency(parsedValue.amount, parsedValue.currency);
        };
      case "date":
        return function(cell: any) {
          const value = cell.getValue();
          if (!value) return '';
          try {
            return new Date(value).toLocaleDateString('tr-TR');
          } catch {
            return value;
          }
        };
      case "boolean":
      case "checkbox":
        return "tickCross";
      default:
        return function(cell: any) {
          const value = cell.getValue();
          return value || '';
        };
    }
  };

  // Global function for cell link click
  useEffect(() => {
    (window as any).handleCellLinkClick = (rowId: string, columnName: string) => {
      console.log("Cell link clicked:", { rowId, columnName });
      setCellLinkData({
        sourceRowId: rowId,
        sourceColumnName: columnName
      });
      setShowCellLinkModal(true);
    };

    return () => {
      delete (window as any).handleCellLinkClick;
    };
  }, []);

  // Initialize Tabulator
  useEffect(() => {
    if (!tabulatorRef.current || columnsLoading || dataLoading || !actualTableUUID) return;

    const initTabulator = async () => {
      try {
        await loadTabulator();

        if (!window.Tabulator) {
          throw new Error('Tabulator failed to load');
        }

        // Destroy existing instance
        if (tabulatorInstance.current) {
          tabulatorInstance.current.destroy();
        }

        // Transform data for tabulator
        const transformedData = (tableData as any[]).map((row: any) => {
          try {
            // Supabase'den gelen row_data JSON string'ini parse et
            const rowData = typeof row.row_data === 'string' 
              ? JSON.parse(row.row_data) 
              : (row.row_data || {});
            
            return {
              id: row.id,
              ...rowData,
            };
          } catch (error) {
            console.error('Error parsing row data:', error);
            return {
              id: row.id,
              ...row.rowData, // fallback to old format
            };
          }
        });

        const tabulatorColumns = getTabulatorColumns();

        // Create new instance
        tabulatorInstance.current = new window.Tabulator(tabulatorRef.current, {
          data: transformedData,
          columns: tabulatorColumns,
          layout: "fitColumns",
          height: "400px",
          placeholder: "Veri bulunamadƒ±",
          tooltips: true,
          movableColumns: true,
          resizableRows: true,
          pagination: "local",
          paginationSize: 25,
          paginationSizeSelector: [10, 25, 50, 100],
          paginationCounter: "rows",
          langs: {
            "tr": {
              "pagination": {
                "page_size": "Sayfa ba≈üƒ±na",
                "first": "ƒ∞lk",
                "first_title": "ƒ∞lk Sayfa",
                "last": "Son",
                "last_title": "Son Sayfa",
                "prev": "√ñnceki",
                "prev_title": "√ñnceki Sayfa",
                "next": "Sonraki",
                "next_title": "Sonraki Sayfa"
              }
            }
          },
          locale: "tr",
          headerFilterPlaceholder: "Filtrele...",
          selectable: true,
          responsiveLayout: "hide",
          editTriggerEvent: "dblclick", // Double click to edit
          tabEndNewRow: true, // Allow tab to create new row
          cellContextMenu: [
            {
              label: "üîó Data Link", 
              action: function(e: any, cell: any) {
                const rowId = cell.getRow().getData().id;
                const columnName = cell.getField();
                (window as any).handleCellLinkClick(rowId, columnName);
              }
            },
            {
              label: "üí± Currency Change", 
              action: function(e: any, cell: any) {
                const rowId = cell.getRow().getData().id;
                const columnName = cell.getField();
                setCellLinkData({
                  sourceRowId: rowId,
                  sourceColumnName: columnName
                });
                setShowCellLinkModal(true);
                // Set modal to currency mode - we'll implement this
                setTimeout(() => {
                  (document.querySelector('[data-mode="currency"]') as HTMLElement)?.click();
                }, 100);
              }
            },
            {
              label: "üßÆ Form√ºl Ekle", 
              action: function(e: any, cell: any) {
                const rowId = cell.getRow().getData().id;
                const columnName = cell.getField();
                setCellLinkData({
                  sourceRowId: rowId,
                  sourceColumnName: columnName
                });
                setShowCellLinkModal(true);
                // Set modal to formula mode - we'll implement this
                setTimeout(() => {
                  (document.querySelector('[data-mode="formula"]') as HTMLElement)?.click();
                }, 100);
              }
            },
            {
              label: "üóëÔ∏è Delete Row", 
              action: function(e: any, cell: any) {
                const rowId = cell.getRow().getData().id;
                if (confirm("Bu satƒ±rƒ± silmek istediƒüinizden emin misiniz?")) {
                  // Delete row using dbService
                  dbService.deleteData('dynamic_table_data', rowId).then(() => {
                    queryClient.invalidateQueries({ queryKey: [`dynamic-table-data-${tableId}`] });
                    toast({
                      title: "Ba≈üarƒ±lƒ±",
                      description: "Satƒ±r ba≈üarƒ±yla silindi"
                    });
                  }).catch((error) => {
                    console.error('Row deletion error:', error);
                    toast({
                      title: "Hata", 
                      description: "Satƒ±r silinirken hata olu≈ütu",
                      variant: "destructive"
                    });
                  });
                }
              }
            }
          ],
        });

        // Global fonksiyon - Modal'dan sonra h√ºcre g√ºncellemesi i√ßin
        (window as any).updateCellAfterFormula = (rowId: string, columnName: string, calculatedValue: string) => {
          if (tabulatorInstance.current) {
            try {
              console.log('üîç TABULATOR DEBUG:');
              console.log('  - Aranan rowId:', rowId);
              console.log('  - T√ºm satƒ±rlar:', tabulatorInstance.current.getData().map((r: any) => ({ id: r.id, data: r })));
              
              const row = tabulatorInstance.current.getRow(rowId);
              console.log('  - Bulunan row:', row);
              
              if (row) {
                console.log('  - G√ºncellemeden √∂nce:', row.getData());
                row.update({ [columnName]: calculatedValue });
                console.log('  - G√ºncellemeden sonra:', row.getData());
                
                // Tabulator'ƒ± g√∂rsel olarak yenile
                tabulatorInstance.current.redraw();
                console.log('üîÑ Tabulator redraw yapƒ±ldƒ±');
                
                // React Query cache'ini de invalidate et
                queryClient.invalidateQueries({ queryKey: [`/api/dynamic-tables/${tableId}/data`] });
                console.log('üîÑ React Query cache invalidated');
                
                console.log(`üéØ H√ºcre g√ºncellendi: ${rowId}-${columnName} = ${calculatedValue}`);
              } else {
                console.log('‚ùå Row bulunamadƒ±! ID uyu≈ümuyor');
                // Alternatif: Index ile g√ºncelleme deneyelim
                const allRows = tabulatorInstance.current.getRows();
                console.log('  - Toplam satƒ±r sayƒ±sƒ±:', allRows.length);
                allRows.forEach((r: any, index: number) => {
                  const data = r.getData();
                  console.log(`    Satƒ±r ${index}: id=${data.id}`);
                  if (data.id === rowId) {
                    console.log('    ‚úÖ ID e≈üle≈üti! Index ile g√ºncellenecek');
                    r.update({ [columnName]: calculatedValue });
                  }
                });
              }
            } catch (error) {
              console.error('‚ùå H√ºcre g√ºncellenemedi:', error);
            }
          }
        };

      } catch (error) {
        console.error("Error initializing tabulator:", error);
        toast({
          title: "Hata",
          description: "Tablo y√ºklenirken hata olu≈ütu",
          variant: "destructive",
        });
      }
    };

    initTabulator();

    return () => {
      if (tabulatorInstance.current) {
        try {
          tabulatorInstance.current.destroy();
        } catch (error) {
          console.error("Error destroying tabulator:", error);
        }
      }
    };
  }, [columns, tableData, columnsLoading, dataLoading, actualTableUUID]);

  const handleAddColumn = () => {
    createColumnMutation.mutate({
      ...columnForm,
      sortOrder: columns.length,
    });
  };

  const handleUpdateColumn = () => {
    if (editingColumn) {
      updateColumnMutation.mutate({
        id: editingColumn.id,
        data: columnForm,
      });
    }
  };

  const handleDeleteColumn = (columnId: string) => {
    if (confirm("Bu s√ºtunu silmek istediƒüinizden emin misiniz?")) {
      deleteColumnMutation.mutate(columnId);
    }
  };

  const handleAddRow = () => {
    const newRowData: any = {};
    (columns as DynamicColumn[]).forEach((col: DynamicColumn) => {
      newRowData[col.name] = col.defaultValue || "";
    });
    
    createRowMutation.mutate(newRowData);
  };

  const startEditColumn = (column: DynamicColumn) => {
    setEditingColumn(column);
    setColumnForm({
      name: column.name,
      displayName: column.displayName,
      dataType: column.dataType,
      isRequired: column.isRequired,
      isEditable: column.isEditable,
      defaultValue: column.defaultValue || "",
      width: column.width || 150,
      currency: "TRY",
    });
    setShowColumnDialog(true);
  };

  if (columnsLoading || dataLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <div className="w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-600">Y√ºkleniyor...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Table Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          {/* Row Management */}
          <Button 
            variant="default" 
            size="sm" 
            onClick={handleAddRow}
            disabled={columns.length === 0}
            data-testid="button-add-row"
          >
            <Plus className="w-4 h-4 mr-2" />
            Satƒ±r Ekle
          </Button>
        </div>
        <div className="flex items-center space-x-2">
          <Button variant="outline" size="sm" data-testid="button-export">
            Dƒ±≈üa Aktar
          </Button>
          {/* Column Management */}
          <Dialog open={showColumnDialog} onOpenChange={setShowColumnDialog}>
            <DialogTrigger asChild>
              <Button variant="outline" size="sm" data-testid="button-add-column">
                <Plus className="w-4 h-4 mr-2" />
                Yeni S√ºtun
              </Button>
            </DialogTrigger>
            <DialogContent className="max-w-2xl">
              <DialogHeader>
                <DialogTitle>
                  {editingColumn ? "S√ºtun D√ºzenle" : "Yeni S√ºtun Ekle"}
                </DialogTitle>
                <DialogDescription>
                  {editingColumn ? "S√ºtun √∂zelliklerini d√ºzenleyin. S√ºtun ba≈ülƒ±ƒüƒ±na saƒü tƒ±klayarak da bu men√ºye ula≈üabilirsiniz." : "Tabloya yeni s√ºtun ekleyin"}
                </DialogDescription>
              </DialogHeader>
              
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="name">S√ºtun Adƒ±</Label>
                  <Input
                    id="name"
                    value={columnForm.name}
                    onChange={(e) => setColumnForm({ ...columnForm, name: e.target.value })}
                    placeholder="ornek_sutun"
                    disabled={!!editingColumn}
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="displayName">G√∂r√ºnen Ad</Label>
                  <Input
                    id="displayName"
                    value={columnForm.displayName}
                    onChange={(e) => setColumnForm({ ...columnForm, displayName: e.target.value })}
                    placeholder="√ñrnek S√ºtun"
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="dataType">Veri Tipi</Label>
                  <Select
                    value={columnForm.dataType}
                    onValueChange={(value) => setColumnForm({ ...columnForm, dataType: value })}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {DATA_TYPES.map((type) => (
                        <SelectItem key={type.value} value={type.value}>
                          {type.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="width">Geni≈ülik (px)</Label>
                  <Input
                    id="width"
                    type="number"
                    value={columnForm.width}
                    onChange={(e) => setColumnForm({ ...columnForm, width: parseInt(e.target.value) || 150 })}
                    placeholder="150"
                  />
                </div>
                
                <div className="space-y-2 col-span-2">
                  <Label htmlFor="defaultValue">Varsayƒ±lan Deƒüer</Label>
                  <Input
                    id="defaultValue"
                    value={columnForm.defaultValue}
                    onChange={(e) => setColumnForm({ ...columnForm, defaultValue: e.target.value })}
                    placeholder="Varsayƒ±lan deƒüer"
                  />
                </div>

              </div>

              <div className="flex items-center justify-between pt-4">
                <div className="flex space-x-4">
                  <Button
                    onClick={editingColumn ? handleUpdateColumn : handleAddColumn}
                    disabled={!columnForm.name || !columnForm.displayName}
                  >
                    {editingColumn ? "G√ºncelle" : "Ekle"}
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => {
                      setShowColumnDialog(false);
                      setEditingColumn(null);
                      setColumnForm({
                        name: "",
                        displayName: "",
                        dataType: "text",
                        isRequired: false,
                        isEditable: true,
                        defaultValue: "",
                        width: 150,
                        currency: "TRY",
                      });
                    }}
                  >
                    ƒ∞ptal
                  </Button>
                </div>
                
                {editingColumn && (
                  <Button
                    variant="destructive"
                    onClick={() => {
                      handleDeleteColumn(editingColumn.id);
                      setShowColumnDialog(false);
                      setEditingColumn(null);
                    }}
                  >
                    S√ºtunu Sil
                  </Button>
                )}
              </div>
            </DialogContent>
          </Dialog>
        </div>
      </div>

      {/* Instructions */}
      {columns.length > 0 && (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <div className="flex items-center space-x-2">
            <Settings className="w-5 h-5 text-blue-600" />
            <div className="text-sm text-blue-800">
              <p><strong>ƒ∞pucu:</strong> S√ºtun ba≈ülƒ±ƒüƒ±ndaki √º√ß nokta (...) men√ºs√ºne tƒ±klayarak s√ºtunu d√ºzenleyebilirsiniz.</p>
              <p><strong>Veri Baƒülama:</strong> Herhangi bir h√ºcreye <strong>saƒü tƒ±klayarak</strong> ba≈üka tablolardan veri baƒülayabilirsiniz.</p>
            </div>
          </div>
        </div>
      )}

      {/* Tabulator Container */}
      <div ref={tabulatorRef} className="border rounded-lg overflow-hidden" />
      
      {/* Cell Link Modal */}
      {cellLinkData && (
        <CellLinkModal
          isOpen={showCellLinkModal}
          onClose={() => {
            setShowCellLinkModal(false);
            setCellLinkData(null);
          }}
          sourceTableId={tableId}
          sourceRowId={cellLinkData.sourceRowId}
          sourceColumnName={cellLinkData.sourceColumnName}
        />
      )}
    </div>
  );
}